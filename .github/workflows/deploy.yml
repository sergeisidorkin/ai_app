name: Deploy

on:
  # как и раньше: запуск после успешного CI на main
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main]

  # новый автозапуск при пуше релизных тегов вида v*
  push:
    tags: [ "v*" ]

  # новый автозапуск при публикации релиза
  release:
    types: [ published ]

  # ручной запуск из Actions
  workflow_dispatch: {}

concurrency:
  # отдельная «очередь» на каждый ref (ветка/тег), чтобы не было гонок
  group: deploy-${{ github.ref || github.event.release.tag_name || 'main' }}
  cancel-in-progress: true

jobs:
  deploy:
    # когда запускаться:
    #  - после успешного CI (workflow_run + success)
    #  - при push тега v*
    #  - при публикации релиза
    #  - при ручном запуске
    if: >
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
      || (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v'))
      || (github.event_name == 'release' && github.event.action == 'published')
      || (github.event_name == 'workflow_dispatch')

    runs-on: ubuntu-latest

    # эти переменные передадим на удалённый сервер (ssh-action умеет)
    env:
      GITHUB_EVENT_NAME: ${{ github.event_name }}
      GITHUB_REF_NAME:   ${{ github.ref_name }}                        # имя ветки/тега (без refs/…)
      RELEASE_TAG:       ${{ github.event.release.tag_name || '' }}    # имя тега при release
      # дефолтный реф для деплоя (если событие не даёт ref_name)
      DEPLOY_REF:        ${{ github.event_name == 'release' && github.event.release.tag_name || github.ref_name || 'main' }}

    steps:
      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          command_timeout: 15m
          # Передаём env в удалённый шелл
          envs: GITHUB_EVENT_NAME,GITHUB_REF_NAME,RELEASE_TAG,DEPLOY_REF
          script: |
            set -euo pipefail

            APP_DIR="$HOME/ai_appdir"
            REPO_DIR="$APP_DIR/ai_app"
            VENV_DIR="$APP_DIR/ai_appenv"
            VENV_ACT="$VENV_DIR/bin/activate"
            ENV_PATH_FILE="$APP_DIR/env/prod.env"
            REPO_SSH="git@github.com:sergeisidorkin/ai_app.git"

            echo "== Preflight =="
            mkdir -p "$APP_DIR" "$APP_DIR/env" "$APP_DIR/run"

            if [ ! -d "$REPO_DIR/.git" ]; then
              echo "Cloning repo..."
              git clone "$REPO_SSH" "$REPO_DIR"
            fi

            if [ ! -d "$VENV_DIR" ]; then
              echo "Creating venv..."
              python3 -m venv "$VENV_DIR"
            fi

            test -f "$ENV_PATH_FILE" || { echo "prod.env not found: $ENV_PATH_FILE" >&2; exit 1; }

            echo "== Sync repo =="
            cd "$REPO_DIR"
            if ! git remote -v | grep -q "$REPO_SSH"; then
              git remote set-url origin "$REPO_SSH"
            fi

            git fetch --all --prune --tags

            # Выберем, что деплоить:
            # - release: опубликованный тег
            # - push тегов: сам тег
            # - workflow_run / ручной: ветка main по умолчанию
            REF="${DEPLOY_REF:-main}"
            echo "DEPLOY_REF=${REF}"
            git reset --hard
            git clean -fd

            if [ "$REF" = "main" ]; then
              git checkout -f -B main origin/main
              TARGET_DESC="origin/main"
            elif git rev-parse -q --verify "refs/tags/$REF" >/dev/null; then
              git checkout -f "tags/$REF"
              TARGET_DESC="tag:$REF"
            elif git rev-parse -q --verify "origin/$REF" >/dev/null; then
              git checkout -f -B "$REF" "origin/$REF"
              TARGET_DESC="origin/$REF"
            else
              # как последний шанс — попробуем как SHA
              git checkout -f "$REF" || true
              TARGET_DESC="sha:$REF"
            fi

            echo "Deploying commit: $(git rev-parse --short HEAD) ($TARGET_DESC)"

            echo "== Python deps =="
            . "$VENV_ACT"
            python -m pip install --upgrade pip wheel
            pip install --no-cache-dir -r requirements.txt

            echo "== Export env from $ENV_PATH_FILE =="
            set -a
            . "$ENV_PATH_FILE"
            set +a

            export DJANGO_SETTINGS_MODULE=settings
            export DJANGO_ENV=${DJANGO_ENV:-prod}
            export READ_DOTENV=${READ_DOTENV:-False}
            export PYTHONPATH="$REPO_DIR:${PYTHONPATH:-}"

            echo "== Django checks & migrations =="
            python -m django check --deploy
            python -m django migrate --noinput
            python -m django collectstatic --noinput

            echo "== Restart gunicorn =="
            sudo systemctl restart ai_app

            echo "== Healthcheck (gunicorn socket) =="
            ok=0
            for i in {1..40}; do
              if curl -sS --fail \
                --unix-socket "$APP_DIR/run/gunicorn.sock" \
                -H "Host: imcmontanai.ru" \
                -H "X-Forwarded-Proto: https" \
                http://unix/health/ >/dev/null; then
                ok=1; break
              fi
              sleep 0.5
            done

            if [ "$ok" -ne 1 ]; then
              echo "Gunicorn health failed — showing logs:"
              systemctl status --no-pager ai_app || true
              journalctl -u ai_app -n 200 --no-pager || true
              exit 1
            fi

            echo "== External HTTPS check =="
            curl --fail -I https://imcmontanai.ru/health/ | grep -q "200 OK"
            echo "Deploy OK"