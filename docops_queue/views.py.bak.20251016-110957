# ai_app/docops_queue/views.py
import json
from datetime import timedelta
from urllib.parse import urlparse, urlunparse
from uuid import UUID
from django.shortcuts import get_object_or_404

from django.conf import settings
from django.db import transaction
from django.http import JsonResponse, HttpResponseBadRequest
from django.utils import timezone
from django.views.decorators.http import require_POST, require_GET
from django.views.decorators.csrf import csrf_exempt

from .models import Job

def _normalize_url(u: str) -> str:
    # убираем query/fragment, тримим слеш в конце
    try:
        p = urlparse((u or "").strip())
        p = p._replace(query="", fragment="")
        s = urlunparse(p)
        return s.rstrip("/")
    except Exception:
        return (u or "").strip().rstrip("/")

def _ms_word_link(web_url: str) -> str:
    return f"ms-word:ofe|u|{web_url}"

@csrf_exempt
@require_POST
def enqueue(request):
    """
    ТЕСТОВЫЙ endpoint: положить job в очередь.
    body: { "docUrl": "...", "payload": {...}, "priority": 10 }
    """
    try:
        data = json.loads(request.body.decode("utf-8"))
    except Exception as e:
        return HttpResponseBadRequest(f"bad json: {e}")

    doc_url = _normalize_url(data.get("docUrl") or "")
    payload = data.get("payload") or {}
    priority = int(data.get("priority") or 10)

    if not doc_url:
        return HttpResponseBadRequest("docUrl required")

    j = Job.objects.create(doc_url=doc_url, payload=payload, priority=priority)
    return JsonResponse({"ok": True, "jobId": str(j.id)})

@csrf_exempt
@require_POST
def agent_pull(request, agent_id: str):
    """
    Агент «тонкий»: дергает каждые N секунд.
    Возвращаем ОДНО задание (или пусто).
    """
    # один агент → просто берём самое раннее QUEUED
    j = Job.objects.filter(status=Job.Status.QUEUED)\
                   .order_by("-priority", "created_at")\
                   .first()
    if not j:
        return JsonResponse({"ok": True, "job": None})

    # пометим как ASSIGNED
    j.status = Job.Status.ASSIGNED
    j.assigned_agent = agent_id
    j.started_at = timezone.now()
    j.attempts += 1
    j.save(update_fields=["status","assigned_agent","started_at","attempts","updated_at"])

    web_url = j.doc_url
    return JsonResponse({
        "ok": True,
        "job": {
            "id": str(j.id),
            "webUrl": web_url,
            "msLink": _ms_word_link(web_url),
        }
    })

@csrf_exempt
@require_POST
def docs_next(request):
    """
    Аддин (function file, без UI) вызывает при открытии/периодически:
    body: { "url": "https://tenant.sharepoint.com/.../Document.docx" }
    Возвращаем payload для самого "свежего" ASSIGNED/QUEUED по ЭТОМУ документу.
    (В одном агенте этого достаточно.)
    """
    try:
        data = json.loads(request.body.decode("utf-8"))
    except Exception as e:
        return HttpResponseBadRequest(f"bad json: {e}")

    doc_url = _normalize_url(data.get("url") or "")
    if not doc_url:
        return HttpResponseBadRequest("url required")

    # Сначала ищем ASSIGNED по этому документу (агент уже открыл)
    j = Job.objects.filter(doc_url=doc_url, status=Job.Status.ASSIGNED)\
                   .order_by("-priority", "created_at").first()

    # На самый первый запуск можно позволить аддину забрать QUEUED,
    # если агент открыл документ вручную (dev сценарии)
    if not j:
        j = Job.objects.filter(doc_url=doc_url, status=Job.Status.QUEUED)\
                       .order_by("-priority", "created_at").first()
        if j:
            j.status = Job.Status.ASSIGNED
            j.assigned_agent = j.assigned_agent or "addin-auto"
            j.started_at = timezone.now()
            j.attempts += 1
            j.save(update_fields=["status","assigned_agent","started_at","attempts","updated_at"])

    if not j:
        return JsonResponse({"ok": True, "job": None})

    # Переводим в IN_PROGRESS, чтобы не отдали повторно (в одном агенте этого достаточно)
    if j.status != Job.Status.IN_PROGRESS:
        j.status = Job.Status.IN_PROGRESS
        j.save(update_fields=["status","updated_at"])

    return JsonResponse({
        "ok": True,
        "job": {
            "id": str(j.id),
            "payload": j.payload,
        }
    })

@csrf_exempt
@require_POST
def job_complete(request, job_id):
    try:
        data = json.loads(request.body.decode("utf-8"))
    except Exception as e:
        return HttpResponseBadRequest(f"bad json: {e}")

    ok = bool(data.get("ok"))
    message = (data.get("message") or "")[:2000]
    # опционально: метрики, счетчики, длительность и т.д.

    try:
        j = Job.objects.get(id=job_id)
    except Job.DoesNotExist:
        return HttpResponseBadRequest("job not found")

    j.status = Job.Status.DONE if ok else Job.Status.FAILED
    j.last_error = "" if ok else (message or "failed")
    j.finished_at = timezone.now()
    j.save(update_fields=["status","last_error","finished_at","updated_at"])

    return JsonResponse({"ok": True})

@require_GET
def job_detail(request, job_id: UUID):
    j = get_object_or_404(Job, id=job_id)
    return JsonResponse({
        "id": str(j.id),
        "status": j.status,
        "priority": j.priority,
        "docUrl": j.doc_url,
        "payload": j.payload,
        "assignedAgent": j.assigned_agent,
        "attempts": j.attempts,
        "lastError": j.last_error,
        "createdAt": j.created_at.isoformat(),
        "updatedAt": j.updated_at.isoformat(),
        "startedAt": j.started_at.isoformat() if j.started_at else None,
        "finishedAt": j.finished_at.isoformat() if j.finished_at else None,
    })